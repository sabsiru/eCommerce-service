# EDA 리팩토링

---

## 1. 재고 감소 이벤트 (StockDecreaseEvent)

* `phase = TransactionPhase.BEFORE_COMMIT`

- 재고가 부족할 경우 결제 트랜잭션을 롤백해야 하기 때문에, 결제와 동일한 트랜잭션에서 처리해 데이터 정합성을 보장합니다.

---

## 2. 쿠폰 검증 및 사용 이벤트 (CouponValidateEvent)

* `phase = TransactionPhase.BEFORE_COMMIT`

  - 결제가 실패하면 쿠폰 사용도 함께 롤백되어야 하므로 동일 트랜잭션에서 처리해 데이터 정합성을 유지합니다.

---

## 3. 포인트 사용 이벤트 (PointUseEvent)

* `phase = TransactionPhase.BEFORE_COMMIT`

  * 포인트 차감이 실패할 경우 결제 트랜잭션을 롤백해야 하기 때문에, 결제와 동일한 트랜잭션에서 처리해 데이터 정합성을 보장합니다.

---

## 4. 결제 완료 이벤트 (PaymentCompletedEvent)

* `phase = TransactionPhase.AFTER_COMMIT`

 * 결제가 완료된 이후에 실행되어야 하는 작업(예: 데이터 플랫폼 전송)이므로, 결제 트랜잭션 커밋 이후 단계에서 처리합니다.

---

> 결제 과정의 핵심 작업(재고 감소, 쿠폰 사용, 포인트 사용)은 결제와 동일한 트랜잭션에서 처리해 데이터 정합성을 보장합니다. 반면, 결제 이후의 추가 작업(데이터 플랫폼 전송)은 독립된 트랜잭션으로 분리해 전체 시스템의 안정성을 유지합니다.

## MSA 확장 시 분산 트랜잭션으로 인한 데이터 정합성

향후 서비스가 MSA로 분리되어 트랜잭션 경계가 물리적으로 분산될 경우, 단일 트랜잭션 롤백만으로는 정합성을 유지하기 어렵습니다. 이때는 **Saga 패턴(보상 트랜잭션 기반)** 이나 **2PC(2-Phase Commit)** 같은 분산 트랜잭션 관리 기법을 도입해 각 서비스 간 데이터 일관성을 확보해야 합니다.